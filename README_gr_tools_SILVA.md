How to use our code:

1: [Harrison has a code that produces 6N action variables (J/mass)]

2: Make the directory labeled "outputs_data" BEFORE compiling the following C code. Compile the C code "calling.c" using the following command "gcc -DIS_RK4_J_DOT calling.c resonance_find.c kerrtraj.c kerrmode.c kerrgwem.c J_dot.c J2J_dot.c -w -o [INSERT NAME]." This will generate an executible file with the name "[INSERT NAME]" that takes the following inputs: initial action variables (doubles), initial time (double), number of time steps (long), system label (long), system type (char; inner or outer). In order to run these executible files for each line in the files provided in Step 1, we use the python code "J_evolve_single.py." You can set the initial time, number of time steps, and data file name in lines 27-29 before executing the python code "J_evolve_single.py." The output will be will be the system label, the time, the action variables of that time, the corresponding frequencies (in the r, \theta, and \phi directions), and the time step. The output will go into a directory called "outputs_data" in txt format with file names "J_evolve_[system type]_[system label].txt"

3: [Harrison gives me a large file with all the resonances (from the resonance finder code)]

4: Make the directory labeled "Output_Delta_J" BEFORE compiling the following C code. Compile the C code "calling.c" using the following command "gcc calling.c -DIS_DELTA_J_SINGLE kerrtraj.c kerrmode.c kerrgwem.c resonance_find.c Gamma.c Delta_J.c J_dot.c -o [INSERT NAME] -w." This will generate an executible file with the name "[INSERT NAME]" that takes in the data from the resonance file and outputs the change in the action variables due to the resonance interaction. The python code "Delta_J_single_parallel.py" will run the executible file in parallel. On line 35 in the python file, input the name of the file with the resonance data (Step 3) and declare the number of parallel jobs you want to execute per run on line 52. Once the executible file is made, run the python code "Delta_J_single_parallel.py." The output file will have the resonance label (long; which resonance from the resonance file are we computing), the system label (long; in which system does this resonance occur), the integer mode labels for the inner and outer body (int; n_inner, k_inner, n_outer, k_outer, m_outer), the fundamental resonant angle (double; location on the torus), the total angular acceleration multiplied by the mass of each body (Gamma_outer - Gamma_inner), and the final change in action variables (double; J/(mass_inner)). The files will be in txt format in the directory "Output_Delta_J" with the naming scheme "Delta_J_log_{tot_chunk}_{chunk + 1}.txt," where tot_chunk is the total number of runs needed to cover the entire resonance data file (Step 3) and chunk+1 is the job in that run.

5: [Figure out how we will classify resonances for astrophysical comparisons. Most likely compare the relative change in the action to the values of the action before the resonance. If this ratio is much smaller than 1, it is a perturbation in the same sense as our resonance calculation. If it is order unity/greater than one, the two bodies will undergo a transition to a non-linear interaction.]